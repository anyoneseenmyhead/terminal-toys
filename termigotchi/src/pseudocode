TERMINAL TAMAGOTCHI (Rust) â€” FINAL PRODUCT PSEUDOCODE
====================================================

GOALS
- Deterministic simulation with fixed-step ticking
- Offline progress: load snapshot + last_seen, fast-forward with clamping
- High-fidelity terminal rendering: Braille subpixel canvas -> cell framebuffer -> diff flush
- Skin system: layered sprites with anchors (body + face + accessories + effects)
- Scene-based UI: main, shop, minigame, settings, recap
- Robust persistence: versioned save format + settings

----------------------------------------------------
DATA MODEL
----------------------------------------------------

enum Scene {
  Main,
  Shop,
  Minigame(MinigameKind),
  Settings,
  Recap(CatchupSummary),
  Dead,
}

enum LifeStage { Egg, Baby, Child, Teen, Adult, Elder }

enum Mood { Happy, Okay, Sad, Angry, Sick, Sleepy, Bored }

struct Meters {
  hunger: f32        // 0..100 (100 = full)
  happiness: f32     // 0..100
  health: f32        // 0..100
  energy: f32        // 0..100
  hygiene: f32       // 0..100
  discipline: f32    // 0..100
  bond: f32          // 0..100
  weight: f32        // e.g. 0..200 (species-defined)
}

struct Flags {
  sleeping: bool
  sick: bool
  dirty: bool
  attention_call: bool
  has_poop: bool
  dead: bool
}

struct History {
  // rolling counters for evolution and recap
  neglected_events: u32
  play_events: u32
  feed_events: u32
  clean_events: u32
  discipline_events: u32
  sickness_events: u32
  // optional: ring buffer of meter averages per hour
  hourly_samples: RingBuffer<HourlySample>
}

struct InventoryItem {
  id: String
  kind: ItemKind        // Food, Toy, Cosmetic, Medicine, etc.
  count: u32
}

struct EquippedCosmetics {
  hat_id: Option<String>
  face_id: Option<String>
  shirt_id: Option<String>
  accessory_ids: Vec<String>
}

struct Pet {
  name: String
  species_id: String
  stage: LifeStage
  age_ticks: u64            // 1 tick = rules.tick_step (e.g. 250ms)
  mood: Mood
  meters: Meters
  flags: Flags
  history: History
  equipped: EquippedCosmetics
}

struct Economy {
  coins: u32
  unlocked: Set<String>     // unlocked items/skins
  inventory: Map<String, InventoryItem>
}

struct RNGState {
  seed: u64
  event_counter: u64        // counter-based RNG: rand(seed, event_counter++)
}

struct Rules {
  // tunables; can be loaded per species/skin profile
  tick_step: Duration               // e.g. 250ms (1 tick)
  catchup_step: Duration            // e.g. 5s (used only to batch ticks)
  catchup_max: Duration             // e.g. 7 days
  decay_rates_by_stage: Map<LifeStage, DecayRates>
  sickness_rules: SicknessRules
  evolution_rules: EvolutionRules
  shop_catalog: Vec<CatalogItem>
}

struct GameState {
  version: u32
  pet: Pet
  economy: Economy
  scene: Scene
  rng: RNGState
  // bookkeeping
  sim_ticks: u64             // monotonically increasing simulated ticks
  last_action_at_tick: u64   // sim_ticks timestamp
}

struct SaveFile {
  version: u32
  last_seen_utc: DateTimeUtc
  state: GameState
}

struct Settings {
  save_dir: Path
  skin_name: String
  fps_cap: u32
  enable_color: bool
  enable_braille: bool
  keybinds: Keybinds
  audio: AudioSettings?      // optional later
}

----------------------------------------------------
SKINS / VISUALS
----------------------------------------------------

struct SkinManifest {
  name: String
  author: String
  description: String
  base_resolution: (w_px, h_px)   // pixel grid used by sprites (not terminal cells)
  palette: Option<Palette>        // optional
  anchors: Map<String, Point>     // e.g. "head_top" => (x,y) on base body
  sprites: Map<String, SpriteDef> // body frames, expressions, items
  outfits: Map<String, OutfitDef> // optional: sets of cosmetics
}

struct SpriteDef {
  id: String
  source: SpriteSource            // PNG path or compiled blob
  frames: Vec<FrameRect>          // if spritesheet
  frame_time_ms: u32
  default_offset: Point
  z_index: i32
  anchor_target: Option<String>   // attaches to base anchor if set
  tint: Option<Color>             // optional
}

struct CompositeLayer {
  sprite_id: String
  frame_index: usize
  position_px: Point              // computed from anchors + offsets
  z_index: i32
  opacity: f32
}

Rendering pipeline:
- Build list<CompositeLayer> from pet state + equipped cosmetics + effects
- Sort by z_index
- Draw into offscreen PixelCanvas (subpixel grid) with explicit blend modes
  - Each layer has blend: Normal (alpha), Add, Multiply, Screen (approx)
  - Draw clipped to viewport rect
- Convert PixelCanvas -> CellBuffer (braille codepoints + fg/bg)
  - Option A (monochrome ink): fg = average ink color, bg = background
  - Option B (two-color quantize): pick fg/bg, map dots to nearest
- Diff CellBuffer vs previous and flush changes

----------------------------------------------------
TERMINAL BACKEND
----------------------------------------------------

struct Cell { ch: char, fg: Color, bg: Color, attrs: Attrs }
struct CellBuffer { w: u16, h: u16, cells: Vec<Cell> }

struct PixelCanvas {
  w: u32            // terminal_cols * 2 for braille
  h: u32            // terminal_rows * 4 for braille
  // each pixel: RGBA or indexed color
  pixels: Vec<Pixel>
}

struct Terminal {
  // wraps crossterm: alt-screen, raw-mode, sync updates, cursor hide
  size_cols: u16
  size_rows: u16
  prev: CellBuffer
  cur: CellBuffer
}

Terminal::begin()
Terminal::end()
Terminal::poll_input(timeout) -> Option<InputEvent>
Terminal::resize_if_needed()
  if resized:
    reallocate prev/cur buffers and pixel canvas
    mark full redraw needed
Terminal::present(diff_only=true)

----------------------------------------------------
ACTIONS / INPUT
----------------------------------------------------

enum PlayerAction {
  Feed(FoodId),
  Play(ToyId),
  Clean,
  Heal,
  SleepToggle,
  Discipline,
  ShopOpen,
  ShopBuy(ItemId),
  EquipCosmetic(ItemId),
  UnequipCosmetic(Slot),
  SettingsOpen,
  SettingsApply(SettingsDelta),
  Back,
  Quit,
}

Input mapping:
- Global: q=quit, esc=back, tab=next panel, arrows=nav, enter=select
- Main: f=feed menu, p=play menu, c=clean, m=medicine, l=lights
- Cosmetics: i=inventory, e=equip
collect_input_nonblocking(frame_dt):
  - cap events per frame
  - coalesce repeats (held arrows)

----------------------------------------------------
SIMULATION ENGINE
----------------------------------------------------

GameState::apply(action):
  match action:
    Feed(food):
      if inventory has food:
        consume 1
        meters.hunger += food.nutrition
        meters.happiness += small
        meters.weight += food.weight_delta
        history.feed_events++
        last_action_at_tick = sim_ticks
        maybe trigger poop after delay
    Play(toy):
      meters.happiness += toy.fun
      meters.energy -= toy.tiring
      meters.hunger -= tiny
      history.play_events++
      award coins sometimes
    Clean:
      meters.hygiene = 100
      flags.dirty = false
      flags.has_poop = false
      history.clean_events++
    Heal:
      if flags.sick:
        flags.sick = false
        meters.health += boost
    SleepToggle:
      flags.sleeping = !flags.sleeping
    Discipline:
      meters.discipline += boost
      flags.attention_call = false
      history.discipline_events++
    ShopBuy(item):
      if coins >= price:
        coins -= price
        inventory[item]++
    EquipCosmetic(item):
      if item owned:
        equipped.slot = item
    Back/Quit/etc:
      handled by scene controller

GameState::tick_fixed_step():
  if flags.dead: return

  // advance sim clock
  sim_ticks += 1
  pet.age_ticks += 1
  dt = rules.tick_step.as_secs_f32()
  // rng.roll() uses counter-based RNG: rand(seed, event_counter++)

  // stage-based decay (clamped to 0..100)
  decay = rules.decay_rates_by_stage[pet.stage]
  meters.hunger -= decay.hunger * dt
  meters.happiness -= decay.happiness * dt
  meters.energy -= decay.energy * dt (unless sleeping)
  meters.hygiene -= decay.hygiene * dt

  // sleeping logic
  if flags.sleeping:
    meters.energy += sleep_recover_rate * dt
    meters.hunger -= sleep_hunger_rate * dt
    maybe wake if fully rested or loud attention events

  // dirty/poop logic
  if flags.has_poop:
    meters.hygiene -= poop_penalty * dt
    flags.dirty = true

  // health/sickness
  if meters.hygiene low or hunger very low:
    chance = sickness_probability(...)
    if rng.roll(chance): flags.sick = true; history.sickness_events++

  if flags.sick:
    meters.health -= sick_health_decay * dt
    meters.happiness -= sick_mood_decay * dt

  // attention calls
  if meters.hunger low OR meters.happiness low:
    if cooldown elapsed and rng.roll(attention_chance):
      flags.attention_call = true

  // mood derivation
  pet.mood = derive_mood(meters, flags)

  // evolution / stage transitions
  if should_advance_stage(pet.age_ticks, history, meters):
    pet.stage = next_stage
    apply_stage_bonus_or_sprite_change()

  // death conditions
  if meters.health <= 0 OR prolonged neglect:
    flags.dead = true
    // scene transition handled by scene controller

  // hourly sampling for evolution metrics
  history.hourly_samples.maybe_push(sample(meters))

----------------------------------------------------
OFFLINE CATCH-UP
----------------------------------------------------

fn load_or_init() -> (GameState, Settings, SkinPack)

fn catch_up(state, last_seen_utc, now_utc, rules) -> CatchupSummary:
  elapsed = now_utc - last_seen_utc
  elapsed = clamp(elapsed, 0..rules.catchup_max)

  summary = CatchupSummary::new()
  remaining = elapsed

  while remaining > 0 and not state.pet.flags.dead:
    step = min(rules.catchup_step, remaining)
    ticks = floor(step / rules.tick_step)
    if ticks == 0: break
    for i in 0..ticks:
      state.tick_fixed_step()
      summary.record_if_thresholds_crossed(state) // compare to cached band state
    remaining -= ticks * rules.tick_step

  return summary

Startup:
  save = read_save()
  if save exists:
    state = save.state
    summary = catch_up(state, save.last_seen_utc, now_utc, rules)
    if summary.has_anything():
      state.scene = Recap(summary)
  else:
    state = new_game_state()

Shutdown/autosave:
  write temp SaveFile, fsync, then atomic rename into place
  best-effort lock to avoid concurrent writers

----------------------------------------------------
SCENE CONTROLLER
----------------------------------------------------

fn update_scene(state, input_events, dt_realtime):
  match state.scene:

    Main:
      handle global hotkeys
      if input opens menus -> push scene
      if attention_call -> show icon/animation
      if dead -> Dead

    Shop:
      nav catalog, buy, back -> Main

    Minigame(kind):
      run minigame loop
      on finish -> award coins/stat changes -> Main

    Settings:
      change fps/skin/colors/keybinds
      apply -> reload skin if changed
      back -> Main

    Recap(summary):
      show summary pages
      any key -> Main

    Dead:
      show tombstone + stats
      options: new game, quit

----------------------------------------------------
MAIN LOOP
----------------------------------------------------

fn main():
  settings = load_settings()
  rules = load_rules(settings)
  skin = load_skin_pack(settings.skin_name)

  terminal.begin()

  state, last_seen = load_or_init_save()
  if loaded:
    summary = catch_up(...)
    if summary.has_anything(): state.scene = Recap(summary)

  // timing
  sim_step = rules.tick_step            // e.g. 250ms
  fps_cap = settings.fps_cap            // e.g. 60
  frame_dt = 1.0 / fps_cap

  sim_accum = 0
  last_frame_time = now()

  loop until quit:
    terminal.resize_if_needed()

    // input
    events = collect_input_nonblocking(frame_dt)

    // apply input -> actions
    for e in events:
      action = map_event_to_action(state.scene, e, settings.keybinds)
      if action == Quit:
        break loop
      else if action != None:
        state.apply(action)

    // simulation ticking (fixed-step)
    now = monotonic_now()
    real_dt = now - last_frame_time
    last_frame_time = now
    sim_accum += real_dt

    while sim_accum >= sim_step:
      state.tick_fixed_step()
      sim_accum -= sim_step

    // render
    renderer.build_layers_from_state(state, skin)
    pixel_canvas.clear()
    renderer.draw_layers(pixel_canvas)

    cell_buffer = braille_encode(pixel_canvas, terminal.size)
    ui_overlay_draw(cell_buffer, state, settings)         // meters, panels, menus
    // UI layout reserves a viewport rect for pet rendering
    terminal.cur = cell_buffer
    terminal.present(diff_only=true)

    // autosave periodically
    if autosave_due():
      save(state, now_utc())

  save(state, now_utc())
  terminal.end()

----------------------------------------------------
NOTES / EXTENSIONS
----------------------------------------------------
- Add "import skin from PNG" command that compiles to cached internal format.
- Add inventory editor/dev mode for creating hats/clothes quickly.
- Add replay log (actions + timestamps) if you want perfect determinism across devices.
- Add accessibility: colorblind palettes, ASCII fallback when Braille unsupported.
